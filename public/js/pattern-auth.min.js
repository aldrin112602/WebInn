const canvas = document.getElementById("patternCanvas"),
    ctx = canvas.getContext("2d"),
    patternOutput = document.getElementById("patternOutput"),
    submitButton = document.getElementById("submitPattern"),
    resetButton = document.getElementById("resetButton"),
    canvasSize = 300,
    gridSize = 3,
    pointRadius = 12,
    arrowSize = 8,
    points = [],
    pattern = [],
    selectedPoints = new Set();
let lastPoint = null,
    currentPoint = null,
    isPatternValid = !0;
const gap = 75;
for (let row = 1; row <= 3; row++)
    for (let col = 1; col <= 3; col++)
        points.push({ x: 75 * col, y: 75 * row, id: (row - 1) * 3 + col });
function resetPattern() {
    (pattern.length = 0),
        selectedPoints.clear(),
        (lastPoint = null),
        (currentPoint = null),
        (isPatternValid = !0),
        (resetButton.style.display = "none"),
        canvas.classList.remove("shake"),
        drawGrid(),
        (patternOutput.textContent = "");
}
function drawArrow(t, e, n, a, i) {
    ctx.save(),
        ctx.translate(t + (n - t) * 0.8, e + (a - e) * 0.8),
        ctx.rotate(Math.atan2(a - e, n - t)),
        ctx.beginPath(),
        ctx.moveTo(-8, -8),
        ctx.lineTo(0, 0),
        ctx.lineTo(-8, 8),
        (ctx.strokeStyle = i),
        (ctx.lineWidth = 2),
        ctx.stroke(),
        ctx.restore();
}
const drawGrid = () => {
        if ((ctx.clearRect(0, 0, 300, 300), pattern.length > 1))
            for (let t = 0; t < pattern.length - 1; t++) {
                let e = points.find((e) => e.id === pattern[t]),
                    n = points.find((e) => e.id === pattern[t + 1]),
                    a = ctx.createLinearGradient(e.x, e.y, n.x, n.y);
                a.addColorStop(0, isPatternValid ? "#4ecdc4" : "#ff5757"),
                    a.addColorStop(1, isPatternValid ? "#2ab7ca" : "#ff3333"),
                    ctx.beginPath(),
                    ctx.moveTo(e.x, e.y),
                    ctx.lineTo(n.x, n.y),
                    (ctx.strokeStyle = a),
                    (ctx.lineWidth = 3),
                    ctx.stroke(),
                    ctx.closePath(),
                    drawArrow(e.x, e.y, n.x, n.y, "#ffffff");
            }
        if (lastPoint && currentPoint) {
            let i = ctx.createLinearGradient(
                lastPoint.x,
                lastPoint.y,
                currentPoint.x,
                currentPoint.y
            );
            i.addColorStop(0, isPatternValid ? "#4ecdc4" : "#ff5757"),
                i.addColorStop(1, isPatternValid ? "#2ab7ca" : "#ff3333"),
                ctx.beginPath(),
                ctx.moveTo(lastPoint.x, lastPoint.y),
                ctx.lineTo(currentPoint.x, currentPoint.y),
                (ctx.strokeStyle = i),
                (ctx.lineWidth = 3),
                ctx.stroke(),
                ctx.closePath(),
                drawArrow(
                    lastPoint.x,
                    lastPoint.y,
                    currentPoint.x,
                    currentPoint.y,
                    "#ffffff"
                );
        }
        points.forEach((t) => {
            if (
                (ctx.save(),
                ctx.beginPath(),
                ctx.arc(t.x, t.y, 17, 0, 2 * Math.PI),
                (ctx.fillStyle = "rgba(255, 255, 255, 0.1)"),
                (ctx.filter = "blur(3px)"),
                ctx.fill(),
                ctx.restore(),
                ctx.beginPath(),
                ctx.arc(t.x, t.y, 12, 0, 2 * Math.PI),
                (ctx.fillStyle = selectedPoints.has(t.id)
                    ? isPatternValid
                        ? "#4ecdc4"
                        : "#ff5757"
                    : "rgba(255, 255, 255, 0.8)"),
                ctx.fill(),
                ctx.closePath(),
                ctx.beginPath(),
                ctx.arc(t.x, t.y, 8, 0, 2 * Math.PI),
                (ctx.fillStyle = selectedPoints.has(t.id)
                    ? isPatternValid
                        ? "#2ab7ca"
                        : "#ff3333"
                    : "rgba(255, 255, 255, 0.4)"),
                ctx.fill(),
                ctx.closePath(),
                selectedPoints.has(t.id))
            ) {
                let e = pattern.indexOf(t.id) + 1;
                (ctx.fillStyle = "#ffffff"),
                    (ctx.font = "bold 12px Arial"),
                    (ctx.textAlign = "center"),
                    (ctx.textBaseline = "middle"),
                    ctx.fillText(e, t.x, t.y);
            }
        });
    },
    getClosestPoint = (t, e) =>
        points.find((n) => 24 > Math.sqrt((n.x - t) ** 2 + (n.y - e) ** 2));
function getEventCoordinates(t) {
    t.preventDefault();
    let e = canvas.getBoundingClientRect();
    return t.touches && t.touches.length > 0
        ? { x: t.touches[0].clientX - e.left, y: t.touches[0].clientY - e.top }
        : { x: t.clientX - e.left, y: t.clientY - e.top };
}
let isDrawing = !1;
function handleStart(t) {
    isDrawing = !0;
    let { x: e, y: n } = getEventCoordinates(t),
        a = getClosestPoint(e, n);
    a &&
        !selectedPoints.has(a.id) &&
        (selectedPoints.add(a.id),
        pattern.push(a.id),
        (lastPoint = a),
        drawGrid());
}
function handleMove(t) {
    if (!isDrawing) return;
    let { x: e, y: n } = getEventCoordinates(t);
    currentPoint = { x: e, y: n };
    let a = getClosestPoint(e, n);
    a &&
        !selectedPoints.has(a.id) &&
        (selectedPoints.add(a.id), pattern.push(a.id), (lastPoint = a)),
        drawGrid(),
        (resetButton.style.display = "block");
}
function handleEnd(t) {
    (isDrawing = !1),
        (currentPoint = null),
        (patternOutput.textContent = `Pattern: ${pattern.join("-")}`);
}
canvas.addEventListener("mousedown", handleStart),
    canvas.addEventListener("mousemove", handleMove),
    canvas.addEventListener("mouseup", handleEnd),
    canvas.addEventListener("mouseout", handleEnd),
    canvas.addEventListener("touchstart", handleStart, { passive: !1 }),
    canvas.addEventListener("touchmove", handleMove, { passive: !1 }),
    canvas.addEventListener("touchend", handleEnd, { passive: !1 }),
    canvas.addEventListener("touchcancel", handleEnd, { passive: !1 }),
    submitButton.addEventListener("click", () => {
        let t = pattern.join("-");
        t
            ? Swal.fire({
                  title: "Verifying Pattern...",
                  text: "Please wait",
                  timer: 1e3,
                  timerProgressBar: !0,
                  didOpen() {
                      Swal.showLoading(),
                          fetch("/face-recognition/validate-pattern", {
                              method: "POST",
                              headers: {
                                  "Content-Type": "application/json",
                                  "X-CSRF-TOKEN": document.querySelector(
                                      'meta[name="csrf-token"]'
                                  ).content,
                              },
                              body: JSON.stringify({ pattern: t }),
                          })
                              .then((t) => t.json())
                              .then((t) => {
                                  t.success ||
                                      ((isPatternValid = !1),
                                      (resetButton.style.display = "block"),
                                      canvas.classList.add("shake"),
                                      drawGrid()),
                                      Swal.fire({
                                          icon: t.success ? "success" : "error",
                                          title: t.success
                                              ? "Success!"
                                              : "Error!",
                                          text: t.message,
                                          showConfirmButton: !0,
                                      }).then(() => {
                                          t.success &&
                                              (location.href =
                                                  "/face_recognition");
                                      });
                              })
                              .catch((t) => {
                                  Swal.fire({
                                      icon: "error",
                                      title: "Oops...",
                                      text: "Admin pattern is currently unset, please configure the face recognition pattern to proceed.",
                                  }),
                                      console.log(t),
                                      (resetButton.style.display = "block");
                              });
                  },
              })
            : Swal.fire({
                  icon: "warning",
                  title: "No Pattern",
                  text: "Please draw a pattern first.",
              });
    }),
    resetButton.addEventListener("click", resetPattern),
    canvas.addEventListener("contextmenu", (t) => {
        t.preventDefault(), resetPattern();
    }),
    drawGrid(),
    canvas.addEventListener("mouseover", () => {
        canvas.style.transform = "scale(1.02)";
    }),
    canvas.addEventListener("mouseout", () => {
        canvas.style.transform = "scale(1)";
    }),
    (canvas.style.touchAction = "none");
